#ifndef FILAMENT_RENDERING_SERVER_BACKEND_H
#define FILAMENT_RENDERING_SERVER_BACKEND_H

#include "servers/rendering_server.h"
#include "threaded_execution_queue.h"
#include "filament_object_manager.h"
#include "filament_dirty_list.h"

#include <vector>
#include <memory>

namespace filament {
	class Engine;
}

class FilamentWindow;
class FilamentTextureObject;

class FilamentRenderingServerBackend final : public BaseThreadedExecutionQueueBackend {
public:
	FilamentRenderingServerBackend();
	~FilamentRenderingServerBackend() override;

	FilamentRenderingServerBackend(const FilamentRenderingServerBackend &other) = delete;
	FilamentRenderingServerBackend &operator =(const FilamentRenderingServerBackend &other) = delete;

	void texture_2d_create(RID output, const Ref<Image> & p_image) ;
	void texture_2d_layered_create(RID output, const Vector<Ref<Image>> & p_layers, RenderingServer::TextureLayeredType p_layered_type) ;
	void texture_3d_create(RID output, Image::Format anonarg, int p_width, int p_height, int p_depth, bool p_mipmaps, const Vector<Ref<Image>> & p_data) ;
	void texture_proxy_create(RID output, RID p_base) ;
	void texture_2d_update(RID p_texture, const Ref<Image> & p_image, int p_layer) ;
	void texture_3d_update(RID p_texture, const Vector<Ref<Image>> & p_data) ;
	void texture_proxy_update(RID p_texture, RID p_proxy_to) ;
	void texture_2d_placeholder_create(RID output) ;
	void texture_2d_layered_placeholder_create(RID output, RenderingServer::TextureLayeredType p_layered_type) ;
	void texture_3d_placeholder_create(RID output) ;
	Ref<Image> texture_2d_get(RID p_texture) const;
	Ref<Image> texture_2d_layer_get(RID p_texture, int p_layer) const;
	Vector<Ref<Image>> texture_3d_get(RID p_texture) const;
	void texture_replace(RID p_texture, RID p_by_texture) ;
	void texture_set_size_override(RID p_texture, int p_width, int p_height) ;
	void texture_set_path(RID p_texture, const String & p_path) ;
	String texture_get_path(RID p_texture) const;
	Image::Format texture_get_format(RID p_texture) const;
	void texture_set_detect_3d_callback(RID p_texture, RenderingServer::TextureDetectCallback p_callback, void * p_userdata) ;
	void texture_set_detect_normal_callback(RID p_texture, RenderingServer::TextureDetectCallback p_callback, void * p_userdata) ;
	void texture_set_detect_roughness_callback(RID p_texture, RenderingServer::TextureDetectRoughnessCallback p_callback, void * p_userdata) ;
	void texture_debug_usage(List<RenderingServer::TextureInfo> * r_info) ;
	void texture_set_force_redraw_if_visible(RID p_texture, bool p_enable) ;
	void texture_rd_create(RID output, const RID & p_rd_texture, const RenderingServer::TextureLayeredType p_layer_type) ;
	RID texture_get_rd_texture(RID p_texture, bool p_srgb) const;
	uint64_t texture_get_native_handle(RID p_texture, bool p_srgb) const;
	void shader_create(RID output) ;
	void shader_set_code(RID p_shader, const String & p_code) ;
	void shader_set_path_hint(RID p_shader, const String & p_path) ;
	String shader_get_code(RID p_shader) const;
	void get_shader_parameter_list(RID p_shader, List<PropertyInfo> * p_param_list) const;
	Variant shader_get_parameter_default(RID p_shader, const StringName & p_param) const;
	void shader_set_default_texture_parameter(RID p_shader, const StringName & p_name, RID p_texture, int p_index) ;
	RID shader_get_default_texture_parameter(RID p_shader, const StringName & p_name, int p_index) const;
	RenderingServer::ShaderNativeSourceCode shader_get_native_source_code(RID p_shader) const;
	void material_create(RID output) ;
	void material_set_shader(RID p_shader_material, RID p_shader) ;
	void material_set_param(RID p_material, const StringName & p_param, const Variant & p_value) ;
	Variant material_get_param(RID p_material, const StringName & p_param) const;
	void material_set_render_priority(RID p_material, int priority) ;
	void material_set_next_pass(RID p_material, RID p_next_material) ;
	void mesh_create_from_surfaces(RID output, const Vector<RenderingServer::SurfaceData> & p_surfaces, int p_blend_shape_count) ;
	void mesh_create(RID output) ;
	void mesh_set_blend_shape_count(RID p_mesh, int p_blend_shape_count) ;
	void mesh_add_surface(RID p_mesh, const RenderingServer::SurfaceData & p_surface) ;
	int mesh_get_blend_shape_count(RID p_mesh) const;
	void mesh_set_blend_shape_mode(RID p_mesh, RenderingServer::BlendShapeMode p_mode) ;
	RenderingServer::BlendShapeMode mesh_get_blend_shape_mode(RID p_mesh) const;
	void mesh_surface_update_vertex_region(RID p_mesh, int p_surface, int p_offset, const Vector<uint8_t> & p_data) ;
	void mesh_surface_update_attribute_region(RID p_mesh, int p_surface, int p_offset, const Vector<uint8_t> & p_data) ;
	void mesh_surface_update_skin_region(RID p_mesh, int p_surface, int p_offset, const Vector<uint8_t> & p_data) ;
	void mesh_surface_set_material(RID p_mesh, int p_surface, RID p_material) ;
	RID mesh_surface_get_material(RID p_mesh, int p_surface) const;
	RenderingServer::SurfaceData mesh_get_surface(RID p_mesh, int p_surface) const;
	int mesh_get_surface_count(RID p_mesh) const;
	void mesh_set_custom_aabb(RID p_mesh, const AABB & p_aabb) ;
	AABB mesh_get_custom_aabb(RID p_mesh) const;
	void mesh_set_shadow_mesh(RID p_mesh, RID p_shadow_mesh) ;
	void mesh_clear(RID p_mesh) ;
	void multimesh_create(RID output) ;
	void multimesh_allocate_data(RID p_multimesh, int p_instances, RenderingServer::MultimeshTransformFormat p_transform_format, bool p_use_colors, bool p_use_custom_data) ;
	int multimesh_get_instance_count(RID p_multimesh) const;
	void multimesh_set_mesh(RID p_multimesh, RID p_mesh) ;
	void multimesh_instance_set_transform(RID p_multimesh, int p_index, const Transform3D & p_transform) ;
	void multimesh_instance_set_transform_2d(RID p_multimesh, int p_index, const Transform2D & p_transform) ;
	void multimesh_instance_set_color(RID p_multimesh, int p_index, const Color & p_color) ;
	void multimesh_instance_set_custom_data(RID p_multimesh, int p_index, const Color & p_color) ;
	RID multimesh_get_mesh(RID p_multimesh) const;
	AABB multimesh_get_aabb(RID p_multimesh) const;
	Transform3D multimesh_instance_get_transform(RID p_multimesh, int p_index) const;
	Transform2D multimesh_instance_get_transform_2d(RID p_multimesh, int p_index) const;
	Color multimesh_instance_get_color(RID p_multimesh, int p_index) const;
	Color multimesh_instance_get_custom_data(RID p_multimesh, int p_index) const;
	void multimesh_set_buffer(RID p_multimesh, const Vector<float> & p_buffer) ;
	Vector<float> multimesh_get_buffer(RID p_multimesh) const;
	void multimesh_set_visible_instances(RID p_multimesh, int p_visible) ;
	int multimesh_get_visible_instances(RID p_multimesh) const;
	void skeleton_create(RID output) ;
	void skeleton_allocate_data(RID p_skeleton, int p_bones, bool p_2d_skeleton) ;
	int skeleton_get_bone_count(RID p_skeleton) const;
	void skeleton_bone_set_transform(RID p_skeleton, int p_bone, const Transform3D & p_transform) ;
	Transform3D skeleton_bone_get_transform(RID p_skeleton, int p_bone) const;
	void skeleton_bone_set_transform_2d(RID p_skeleton, int p_bone, const Transform2D & p_transform) ;
	Transform2D skeleton_bone_get_transform_2d(RID p_skeleton, int p_bone) const;
	void skeleton_set_base_transform_2d(RID p_skeleton, const Transform2D & p_base_transform) ;
	void directional_light_create(RID output) ;
	void omni_light_create(RID output) ;
	void spot_light_create(RID output) ;
	void light_set_color(RID p_light, const Color & p_color) ;
	void light_set_param(RID p_light, RenderingServer::LightParam p_param, float p_value) ;
	void light_set_shadow(RID p_light, bool p_enabled) ;
	void light_set_projector(RID p_light, RID p_texture) ;
	void light_set_negative(RID p_light, bool p_enable) ;
	void light_set_cull_mask(RID p_light, uint32_t p_mask) ;
	void light_set_distance_fade(RID p_light, bool p_enabled, float p_begin, float p_shadow, float p_length) ;
	void light_set_reverse_cull_face_mode(RID p_light, bool p_enabled) ;
	void light_set_bake_mode(RID p_light, RenderingServer::LightBakeMode p_bake_mode) ;
	void light_set_max_sdfgi_cascade(RID p_light, uint32_t p_cascade) ;
	void light_omni_set_shadow_mode(RID p_light, RenderingServer::LightOmniShadowMode p_mode) ;
	void light_directional_set_shadow_mode(RID p_light, RenderingServer::LightDirectionalShadowMode p_mode) ;
	void light_directional_set_blend_splits(RID p_light, bool p_enable) ;
	void light_directional_set_sky_mode(RID p_light, RenderingServer::LightDirectionalSkyMode p_mode) ;
	void shadow_atlas_create(RID output) ;
	void shadow_atlas_set_size(RID p_atlas, int p_size, bool p_use_16_bits) ;
	void shadow_atlas_set_quadrant_subdivision(RID p_atlas, int p_quadrant, int p_subdivision) ;
	void directional_shadow_atlas_set_size(int p_size, bool p_16_bits) ;
	void positional_soft_shadow_filter_set_quality(RenderingServer::ShadowQuality p_quality) ;
	void directional_soft_shadow_filter_set_quality(RenderingServer::ShadowQuality p_quality) ;
	void light_projectors_set_filter(RenderingServer::LightProjectorFilter p_filter) ;
	void reflection_probe_create(RID output);
	void reflection_probe_set_update_mode(RID p_probe, RenderingServer::ReflectionProbeUpdateMode p_mode) ;
	void reflection_probe_set_intensity(RID p_probe, float p_intensity) ;
	void reflection_probe_set_ambient_mode(RID p_probe, RenderingServer::ReflectionProbeAmbientMode p_mode) ;
	void reflection_probe_set_ambient_color(RID p_probe, const Color & p_color) ;
	void reflection_probe_set_ambient_energy(RID p_probe, float p_energy) ;
	void reflection_probe_set_max_distance(RID p_probe, float p_distance) ;
	void reflection_probe_set_size(RID p_probe, const Vector3 & p_size) ;
	void reflection_probe_set_origin_offset(RID p_probe, const Vector3 & p_offset) ;
	void reflection_probe_set_as_interior(RID p_probe, bool p_enable) ;
	void reflection_probe_set_enable_box_projection(RID p_probe, bool p_enable) ;
	void reflection_probe_set_enable_shadows(RID p_probe, bool p_enable) ;
	void reflection_probe_set_cull_mask(RID p_probe, uint32_t p_layers) ;
	void reflection_probe_set_resolution(RID p_probe, int p_resolution) ;
	void reflection_probe_set_mesh_lod_threshold(RID p_probe, float p_pixels) ;
	void decal_create(RID output) ;
	void decal_set_size(RID p_decal, const Vector3 & p_size) ;
	void decal_set_texture(RID p_decal, RenderingServer::DecalTexture p_type, RID p_texture) ;
	void decal_set_emission_energy(RID p_decal, float p_energy) ;
	void decal_set_albedo_mix(RID p_decal, float p_mix) ;
	void decal_set_modulate(RID p_decal, const Color & p_modulate) ;
	void decal_set_cull_mask(RID p_decal, uint32_t p_layers) ;
	void decal_set_distance_fade(RID p_decal, bool p_enabled, float p_begin, float p_length) ;
	void decal_set_fade(RID p_decal, float p_above, float p_below) ;
	void decal_set_normal_fade(RID p_decal, float p_fade) ;
	void decals_set_filter(RenderingServer::DecalFilter p_quality) ;
	void voxel_gi_create(RID output) ;
	void voxel_gi_allocate_data(RID p_voxel_gi, const Transform3D & p_to_cell_xform, const AABB & p_aabb, const Vector3i & p_octree_size, const Vector<uint8_t> & p_octree_cells, const Vector<uint8_t> & p_data_cells, const Vector<uint8_t> & p_distance_field, const Vector<int> & p_level_counts) ;
	AABB voxel_gi_get_bounds(RID p_voxel_gi) const;
	Vector3i voxel_gi_get_octree_size(RID p_voxel_gi) const;
	Vector<uint8_t> voxel_gi_get_octree_cells(RID p_voxel_gi) const;
	Vector<uint8_t> voxel_gi_get_data_cells(RID p_voxel_gi) const;
	Vector<uint8_t> voxel_gi_get_distance_field(RID p_voxel_gi) const;
	Vector<int> voxel_gi_get_level_counts(RID p_voxel_gi) const;
	Transform3D voxel_gi_get_to_cell_xform(RID p_voxel_gi) const;
	void voxel_gi_set_dynamic_range(RID p_voxel_gi, float p_range) ;
	void voxel_gi_set_propagation(RID p_voxel_gi, float p_range) ;
	void voxel_gi_set_energy(RID p_voxel_gi, float p_energy) ;
	void voxel_gi_set_baked_exposure_normalization(RID p_voxel_gi, float p_baked_exposure) ;
	void voxel_gi_set_bias(RID p_voxel_gi, float p_bias) ;
	void voxel_gi_set_normal_bias(RID p_voxel_gi, float p_range) ;
	void voxel_gi_set_interior(RID p_voxel_gi, bool p_enable) ;
	void voxel_gi_set_use_two_bounces(RID p_voxel_gi, bool p_enable) ;
	void voxel_gi_set_quality(RenderingServer::VoxelGIQuality anonarg) ;
	void sdfgi_reset() ;
	void lightmap_create(RID output) ;
	void lightmap_set_textures(RID p_lightmap, RID p_light, bool p_uses_spherical_haromics) ;
	void lightmap_set_probe_bounds(RID p_lightmap, const AABB & p_bounds) ;
	void lightmap_set_probe_interior(RID p_lightmap, bool p_interior) ;
	void lightmap_set_probe_capture_data(RID p_lightmap, const PackedVector3Array & p_points, const PackedColorArray & p_point_sh, const PackedInt32Array & p_tetrahedra, const PackedInt32Array & p_bsp_tree) ;
	void lightmap_set_baked_exposure_normalization(RID p_lightmap, float p_exposure) ;
	PackedVector3Array lightmap_get_probe_capture_points(RID p_lightmap) const;
	PackedColorArray lightmap_get_probe_capture_sh(RID p_lightmap) const;
	PackedInt32Array lightmap_get_probe_capture_tetrahedra(RID p_lightmap) const;
	PackedInt32Array lightmap_get_probe_capture_bsp_tree(RID p_lightmap) const;
	void lightmap_set_probe_capture_update_speed(float p_speed) ;
	void particles_create(RID output) ;
	void particles_set_mode(RID p_particles, RenderingServer::ParticlesMode p_mode) ;
	void particles_set_emitting(RID p_particles, bool p_enable) ;
	bool particles_get_emitting(RID p_particles) ;
	void particles_set_amount(RID p_particles, int p_amount) ;
	void particles_set_amount_ratio(RID p_particles, float p_amount_ratio) ;
	void particles_set_lifetime(RID p_particles, double p_lifetime) ;
	void particles_set_one_shot(RID p_particles, bool p_one_shot) ;
	void particles_set_pre_process_time(RID p_particles, double p_time) ;
	void particles_set_explosiveness_ratio(RID p_particles, float p_ratio) ;
	void particles_set_randomness_ratio(RID p_particles, float p_ratio) ;
	void particles_set_custom_aabb(RID p_particles, const AABB & p_aabb) ;
	void particles_set_speed_scale(RID p_particles, double p_scale) ;
	void particles_set_use_local_coordinates(RID p_particles, bool p_enable) ;
	void particles_set_process_material(RID p_particles, RID p_material) ;
	void particles_set_fixed_fps(RID p_particles, int p_fps) ;
	void particles_set_interpolate(RID p_particles, bool p_enable) ;
	void particles_set_fractional_delta(RID p_particles, bool p_enable) ;
	void particles_set_collision_base_size(RID p_particles, float p_size) ;
	void particles_set_transform_align(RID p_particles, RenderingServer::ParticlesTransformAlign p_transform_align) ;
	void particles_set_trails(RID p_particles, bool p_enable, float p_length_sec) ;
	void particles_set_trail_bind_poses(RID p_particles, const Vector<Transform3D> & p_bind_poses) ;
	bool particles_is_inactive(RID p_particles) ;
	void particles_request_process(RID p_particles) ;
	void particles_restart(RID p_particles) ;
	void particles_set_subemitter(RID p_particles, RID p_subemitter_particles) ;
	void particles_emit(RID p_particles, const Transform3D & p_transform, const Vector3 & p_velocity, const Color & p_color, const Color & p_custom, uint32_t p_emit_flags) ;
	void particles_set_draw_order(RID p_particles, RenderingServer::ParticlesDrawOrder p_order) ;
	void particles_set_draw_passes(RID p_particles, int p_count) ;
	void particles_set_draw_pass_mesh(RID p_particles, int p_pass, RID p_mesh) ;
	AABB particles_get_current_aabb(RID p_particles) ;
	void particles_set_emission_transform(RID p_particles, const Transform3D & p_transform) ;
	void particles_set_emitter_velocity(RID p_particles, const Vector3 & p_velocity) ;
	void particles_set_interp_to_end(RID p_particles, float p_interp) ;
	void particles_collision_create(RID output) ;
	void particles_collision_set_collision_type(RID p_particles_collision, RenderingServer::ParticlesCollisionType p_type) ;
	void particles_collision_set_cull_mask(RID p_particles_collision, uint32_t p_cull_mask) ;
	void particles_collision_set_sphere_radius(RID p_particles_collision, real_t p_radius) ;
	void particles_collision_set_box_extents(RID p_particles_collision, const Vector3 & p_extents) ;
	void particles_collision_set_attractor_strength(RID p_particles_collision, real_t p_strength) ;
	void particles_collision_set_attractor_directionality(RID p_particles_collision, real_t p_directionality) ;
	void particles_collision_set_attractor_attenuation(RID p_particles_collision, real_t p_curve) ;
	void particles_collision_set_field_texture(RID p_particles_collision, RID p_texture) ;
	void particles_collision_height_field_update(RID p_particles_collision) ;
	void particles_collision_set_height_field_resolution(RID p_particles_collision, RenderingServer::ParticlesCollisionHeightfieldResolution p_resolution) ;
	void fog_volume_create(RID output) ;
	void fog_volume_set_shape(RID p_fog_volume, RenderingServer::FogVolumeShape p_shape) ;
	void fog_volume_set_size(RID p_fog_volume, const Vector3 & p_size) ;
	void fog_volume_set_material(RID p_fog_volume, RID p_material) ;
	void visibility_notifier_create(RID output) ;
	void visibility_notifier_set_aabb(RID p_notifier, const AABB & p_aabb) ;
	void visibility_notifier_set_callbacks(RID p_notifier, const Callable & p_enter_callbable, const Callable & p_exit_callable) ;
	void occluder_create(RID output) ;
	void occluder_set_mesh(RID p_occluder, const PackedVector3Array & p_vertices, const PackedInt32Array & p_indices) ;
	void camera_create(RID output) ;
	void camera_set_perspective(RID p_camera, float p_fovy_degrees, float p_z_near, float p_z_far) ;
	void camera_set_orthogonal(RID p_camera, float p_size, float p_z_near, float p_z_far) ;
	void camera_set_frustum(RID p_camera, float p_size, Vector2 p_offset, float p_z_near, float p_z_far) ;
	void camera_set_transform(RID p_camera, const Transform3D & p_transform) ;
	void camera_set_cull_mask(RID p_camera, uint32_t p_layers) ;
	void camera_set_environment(RID p_camera, RID p_env) ;
	void camera_set_camera_attributes(RID p_camera, RID p_camera_attributes) ;
	void camera_set_use_vertical_aspect(RID p_camera, bool p_enable) ;
	void viewport_create(RID output) ;
	void viewport_set_use_xr(RID p_viewport, bool p_use_xr) ;
	void viewport_set_size(RID p_viewport, int p_width, int p_height) ;
	void viewport_set_active(RID p_viewport, bool p_active) ;
	void viewport_set_parent_viewport(RID p_viewport, RID p_parent_viewport) ;
	void viewport_set_canvas_cull_mask(RID p_viewport, uint32_t p_canvas_cull_mask) ;
	void viewport_attach_to_screen(RID p_viewport, const Rect2 & p_rect, DisplayServer::WindowID p_screen) ;
	void viewport_set_render_direct_to_screen(RID p_viewport, bool p_enable) ;
	void viewport_set_scaling_3d_mode(RID p_viewport, RenderingServer::ViewportScaling3DMode p_scaling_3d_mode) ;
	void viewport_set_scaling_3d_scale(RID p_viewport, float p_scaling_3d_scale) ;
	void viewport_set_fsr_sharpness(RID p_viewport, float p_fsr_sharpness) ;
	void viewport_set_texture_mipmap_bias(RID p_viewport, float p_texture_mipmap_bias) ;
	void viewport_set_update_mode(RID p_viewport, RenderingServer::ViewportUpdateMode p_mode) ;
	void viewport_set_clear_mode(RID p_viewport, RenderingServer::ViewportClearMode p_clear_mode) ;
	RID viewport_get_render_target(RID p_viewport) const;
	RID viewport_get_texture(RID p_viewport) const;
	void viewport_set_environment_mode(RID p_viewport, RenderingServer::ViewportEnvironmentMode p_mode) ;
	void viewport_set_disable_3d(RID p_viewport, bool p_disable) ;
	void viewport_set_disable_2d(RID p_viewport, bool p_disable) ;
	void viewport_attach_camera(RID p_viewport, RID p_camera) ;
	void viewport_set_scenario(RID p_viewport, RID p_scenario) ;
	void viewport_attach_canvas(RID p_viewport, RID p_canvas) ;
	void viewport_remove_canvas(RID p_viewport, RID p_canvas) ;
	void viewport_set_canvas_transform(RID p_viewport, RID p_canvas, const Transform2D & p_offset) ;
	void viewport_set_transparent_background(RID p_viewport, bool p_enabled) ;
	void viewport_set_use_hdr_2d(RID p_viewport, bool p_use_hdr) ;
	void viewport_set_snap_2d_transforms_to_pixel(RID p_viewport, bool p_enabled) ;
	void viewport_set_snap_2d_vertices_to_pixel(RID p_viewport, bool p_enabled) ;
	void viewport_set_default_canvas_item_texture_filter(RID p_viewport, RenderingServer::CanvasItemTextureFilter p_filter) ;
	void viewport_set_default_canvas_item_texture_repeat(RID p_viewport, RenderingServer::CanvasItemTextureRepeat p_repeat) ;
	void viewport_set_global_canvas_transform(RID p_viewport, const Transform2D & p_transform) ;
	void viewport_set_canvas_stacking(RID p_viewport, RID p_canvas, int p_layer, int p_sublayer) ;
	void viewport_set_sdf_oversize_and_scale(RID p_viewport, RenderingServer::ViewportSDFOversize p_oversize, RenderingServer::ViewportSDFScale p_scale) ;
	void viewport_set_positional_shadow_atlas_size(RID p_viewport, int p_size, bool p_16_bits) ;
	void viewport_set_positional_shadow_atlas_quadrant_subdivision(RID p_viewport, int p_quadrant, int p_subdiv) ;
	void viewport_set_msaa_3d(RID p_viewport, RenderingServer::ViewportMSAA p_msaa) ;
	void viewport_set_msaa_2d(RID p_viewport, RenderingServer::ViewportMSAA p_msaa) ;
	void viewport_set_screen_space_aa(RID p_viewport, RenderingServer::ViewportScreenSpaceAA p_mode) ;
	void viewport_set_use_taa(RID p_viewport, bool p_use_taa) ;
	void viewport_set_use_debanding(RID p_viewport, bool p_use_debanding) ;
	void viewport_set_mesh_lod_threshold(RID p_viewport, float p_pixels) ;
	void viewport_set_use_occlusion_culling(RID p_viewport, bool p_use_occlusion_culling) ;
	void viewport_set_occlusion_rays_per_thread(int p_rays_per_thread) ;
	void viewport_set_occlusion_culling_build_quality(RenderingServer::ViewportOcclusionCullingBuildQuality p_quality) ;
	int viewport_get_render_info(RID p_viewport, RenderingServer::ViewportRenderInfoType p_type, RenderingServer::ViewportRenderInfo p_info) ;
	void viewport_set_debug_draw(RID p_viewport, RenderingServer::ViewportDebugDraw p_draw) ;
	void viewport_set_measure_render_time(RID p_viewport, bool p_enable) ;
	double viewport_get_measured_render_time_cpu(RID p_viewport) const;
	double viewport_get_measured_render_time_gpu(RID p_viewport) const;
	RID viewport_find_from_screen_attachment(DisplayServer::WindowID p_id) const;
	void viewport_set_vrs_mode(RID p_viewport, RenderingServer::ViewportVRSMode p_mode) ;
	void viewport_set_vrs_texture(RID p_viewport, RID p_texture) ;
	void sky_create(RID output) ;
	void sky_set_radiance_size(RID p_sky, int p_radiance_size) ;
	void sky_set_mode(RID p_sky, RenderingServer::SkyMode p_mode) ;
	void sky_set_material(RID p_sky, RID p_material) ;
	Ref<Image> sky_bake_panorama(RID p_sky, float p_energy, bool p_bake_irradiance, const Size2i & p_size) ;
	void environment_create(RID output) ;
	void environment_set_background(RID p_env, RenderingServer::EnvironmentBG p_bg) ;
	void environment_set_sky(RID p_env, RID p_sky) ;
	void environment_set_sky_custom_fov(RID p_env, float p_scale) ;
	void environment_set_sky_orientation(RID p_env, const Basis & p_orientation) ;
	void environment_set_bg_color(RID p_env, const Color & p_color) ;
	void environment_set_bg_energy(RID p_env, float p_multiplier, float p_exposure_value) ;
	void environment_set_canvas_max_layer(RID p_env, int p_max_layer) ;
	void environment_set_ambient_light(RID p_env, const Color & p_color, RenderingServer::EnvironmentAmbientSource p_ambient, float p_energy, float p_sky_contribution, RenderingServer::EnvironmentReflectionSource p_reflection_source) ;
	void environment_set_glow(RID p_env, bool p_enable, Vector<float> p_levels, float p_intensity, float p_strength, float p_mix, float p_bloom_threshold, RenderingServer::EnvironmentGlowBlendMode p_blend_mode, float p_hdr_bleed_threshold, float p_hdr_bleed_scale, float p_hdr_luminance_cap, float p_glow_map_strength, RID p_glow_map) ;
	void environment_glow_set_use_bicubic_upscale(bool p_enable) ;
	void environment_set_tonemap(RID p_env, RenderingServer::EnvironmentToneMapper p_tone_mapper, float p_exposure, float p_white) ;
	void environment_set_adjustment(RID p_env, bool p_enable, float p_brightness, float p_contrast, float p_saturation, bool p_use_1d_color_correction, RID p_color_correction) ;
	void environment_set_ssr(RID p_env, bool p_enable, int p_max_steps, float p_fade_in, float p_fade_out, float p_depth_tolerance) ;
	void environment_set_ssr_roughness_quality(RenderingServer::EnvironmentSSRRoughnessQuality p_quality) ;
	void environment_set_ssao(RID p_env, bool p_enable, float p_radius, float p_intensity, float p_power, float p_detail, float p_horizon, float p_sharpness, float p_light_affect, float p_ao_channel_affect) ;
	void environment_set_ssao_quality(RenderingServer::EnvironmentSSAOQuality p_quality, bool p_half_size, float p_adaptive_target, int p_blur_passes, float p_fadeout_from, float p_fadeout_to) ;
	void environment_set_ssil(RID p_env, bool p_enable, float p_radius, float p_intensity, float p_sharpness, float p_normal_rejection) ;
	void environment_set_ssil_quality(RenderingServer::EnvironmentSSILQuality p_quality, bool p_half_size, float p_adaptive_target, int p_blur_passes, float p_fadeout_from, float p_fadeout_to) ;
	void environment_set_sdfgi(RID p_env, bool p_enable, int p_cascades, float p_min_cell_size, RenderingServer::EnvironmentSDFGIYScale p_y_scale, bool p_use_occlusion, float p_bounce_feedback, bool p_read_sky, float p_energy, float p_normal_bias, float p_probe_bias) ;
	void environment_set_sdfgi_ray_count(RenderingServer::EnvironmentSDFGIRayCount p_ray_count) ;
	void environment_set_sdfgi_frames_to_converge(RenderingServer::EnvironmentSDFGIFramesToConverge p_frames) ;
	void environment_set_sdfgi_frames_to_update_light(RenderingServer::EnvironmentSDFGIFramesToUpdateLight p_update) ;
	void environment_set_fog(RID p_env, bool p_enable, const Color & p_light_color, float p_light_energy, float p_sun_scatter, float p_density, float p_height, float p_height_density, float p_aerial_perspective, float p_sky_affect) ;
	void environment_set_volumetric_fog(RID p_env, bool p_enable, float p_density, const Color & p_albedo, const Color & p_emission, float p_emission_energy, float p_anisotropy, float p_length, float p_detail_spread, float p_gi_inject, bool p_temporal_reprojection, float p_temporal_reprojection_amount, float p_ambient_inject, float p_sky_affect) ;
	void environment_set_volumetric_fog_volume_size(int p_size, int p_depth) ;
	void environment_set_volumetric_fog_filter_active(bool p_enable) ;
	Ref<Image> environment_bake_panorama(RID p_env, bool p_bake_irradiance, const Size2i & p_size) ;
	void screen_space_roughness_limiter_set_active(bool p_enable, float p_amount, float p_limit) ;
	void sub_surface_scattering_set_quality(RenderingServer::SubSurfaceScatteringQuality p_quality) ;
	void sub_surface_scattering_set_scale(float p_scale, float p_depth_scale) ;
	void camera_attributes_create(RID output) ;
	void camera_attributes_set_dof_blur_quality(RenderingServer::DOFBlurQuality p_quality, bool p_use_jitter) ;
	void camera_attributes_set_dof_blur_bokeh_shape(RenderingServer::DOFBokehShape p_shape) ;
	void camera_attributes_set_dof_blur(RID p_camera_attributes, bool p_far_enable, float p_far_distance, float p_far_transition, bool p_near_enable, float p_near_distance, float p_near_transition, float p_amount) ;
	void camera_attributes_set_exposure(RID p_camera_attributes, float p_multiplier, float p_exposure_normalization) ;
	void camera_attributes_set_auto_exposure(RID p_camera_attributes, bool p_enable, float p_min_sensitivity, float p_max_sensitivity, float p_speed, float p_scale) ;
	void scenario_create(RID output) ;
	void scenario_set_environment(RID p_scenario, RID p_environment) ;
	void scenario_set_fallback_environment(RID p_scenario, RID p_environment) ;
	void scenario_set_camera_attributes(RID p_scenario, RID p_camera_attributes) ;
	void instance_create(RID output) ;
	void instance_set_base(RID p_instance, RID p_base) ;
	void instance_set_scenario(RID p_instance, RID p_scenario) ;
	void instance_set_layer_mask(RID p_instance, uint32_t p_mask) ;
	void instance_set_pivot_data(RID p_instance, float p_sorting_offset, bool p_use_aabb_center) ;
	void instance_set_transform(RID p_instance, const Transform3D & p_transform) ;
	void instance_attach_object_instance_id(RID p_instance, ObjectID p_id) ;
	void instance_set_blend_shape_weight(RID p_instance, int p_shape, float p_weight) ;
	void instance_set_surface_override_material(RID p_instance, int p_surface, RID p_material) ;
	void instance_set_visible(RID p_instance, bool p_visible) ;
	void instance_set_custom_aabb(RID p_instance, AABB aabb) ;
	void instance_attach_skeleton(RID p_instance, RID p_skeleton) ;
	void instance_set_extra_visibility_margin(RID p_instance, real_t p_margin) ;
	void instance_set_visibility_parent(RID p_instance, RID p_parent_instance) ;
	void instance_set_ignore_culling(RID p_instance, bool p_enabled) ;
	Vector<ObjectID> instances_cull_aabb(const AABB & p_aabb, RID p_scenario) const;
	Vector<ObjectID> instances_cull_ray(const Vector3 & p_from, const Vector3 & p_to, RID p_scenario) const;
	Vector<ObjectID> instances_cull_convex(const Vector<Plane> & p_convex, RID p_scenario) const;
	void instance_geometry_set_flag(RID p_instance, RenderingServer::InstanceFlags p_flags, bool p_enabled) ;
	void instance_geometry_set_cast_shadows_setting(RID p_instance, RenderingServer::ShadowCastingSetting p_shadow_casting_setting) ;
	void instance_geometry_set_material_override(RID p_instance, RID p_material) ;
	void instance_geometry_set_material_overlay(RID p_instance, RID p_material) ;
	void instance_geometry_set_visibility_range(RID p_instance, float p_min, float p_max, float p_min_margin, float p_max_margin, RenderingServer::VisibilityRangeFadeMode p_fade_mode) ;
	void instance_geometry_set_lightmap(RID p_instance, RID p_lightmap, const Rect2 & p_lightmap_uv_scale, int p_lightmap_slice) ;
	void instance_geometry_set_lod_bias(RID p_instance, float p_lod_bias) ;
	void instance_geometry_set_transparency(RID p_instance, float p_transparency) ;
	void instance_geometry_set_shader_parameter(RID p_instance, const StringName & anonarg, const Variant & p_value) ;
	Variant instance_geometry_get_shader_parameter(RID p_instance, const StringName & anonarg) const;
	Variant instance_geometry_get_shader_parameter_default_value(RID p_instance, const StringName & anonarg) const;
	void instance_geometry_get_shader_parameter_list(RID p_instance, List<PropertyInfo> * p_parameters) const;
	TypedArray<Image> bake_render_uv2(RID p_base, const TypedArray<RID> & p_material_overrides, const Size2i & p_image_size) ;
	void canvas_create(RID output) ;
	void canvas_set_item_mirroring(RID p_canvas, RID p_item, const Point2 & p_mirroring) ;
	void canvas_set_modulate(RID p_canvas, const Color & p_color) ;
	void canvas_set_parent(RID p_canvas, RID p_parent, float p_scale) ;
	void canvas_set_disable_scale(bool p_disable) ;
	void canvas_texture_create(RID output) ;
	void canvas_texture_set_channel(RID p_canvas_texture, RenderingServer::CanvasTextureChannel p_channel, RID p_texture) ;
	void canvas_texture_set_shading_parameters(RID p_canvas_texture, const Color & p_base_color, float p_shininess) ;
	void canvas_texture_set_texture_filter(RID p_canvas_texture, RenderingServer::CanvasItemTextureFilter p_filter) ;
	void canvas_texture_set_texture_repeat(RID p_canvas_texture, RenderingServer::CanvasItemTextureRepeat p_repeat) ;
	void canvas_item_create(RID output) ;
	void canvas_item_set_parent(RID p_item, RID p_parent) ;
	void canvas_item_set_default_texture_filter(RID p_item, RenderingServer::CanvasItemTextureFilter p_filter) ;
	void canvas_item_set_default_texture_repeat(RID p_item, RenderingServer::CanvasItemTextureRepeat p_repeat) ;
	void canvas_item_set_visible(RID p_item, bool p_visible) ;
	void canvas_item_set_light_mask(RID p_item, int p_mask) ;
	void canvas_item_set_update_when_visible(RID p_item, bool p_update) ;
	void canvas_item_set_transform(RID p_item, const Transform2D & p_transform) ;
	void canvas_item_set_clip(RID p_item, bool p_clip) ;
	void canvas_item_set_distance_field_mode(RID p_item, bool p_enable) ;
	void canvas_item_set_custom_rect(RID p_item, bool p_custom_rect, const Rect2 & p_rect) ;
	void canvas_item_set_modulate(RID p_item, const Color & p_color) ;
	void canvas_item_set_self_modulate(RID p_item, const Color & p_color) ;
	void canvas_item_set_visibility_layer(RID p_item, uint32_t p_visibility_layer) ;
	void canvas_item_set_draw_behind_parent(RID p_item, bool p_enable) ;
	void canvas_item_add_line(RID p_item, const Point2 & p_from, const Point2 & p_to, const Color & p_color, float p_width, bool p_antialiased) ;
	void canvas_item_add_polyline(RID p_item, const Vector<Point2> & p_points, const Vector<Color> & p_colors, float p_width, bool p_antialiased) ;
	void canvas_item_add_multiline(RID p_item, const Vector<Point2> & p_points, const Vector<Color> & p_colors, float p_width) ;
	void canvas_item_add_rect(RID p_item, const Rect2 & p_rect, const Color & p_color) ;
	void canvas_item_add_circle(RID p_item, const Point2 & p_pos, float p_radius, const Color & p_color) ;
	void canvas_item_add_texture_rect(RID p_item, const Rect2 & p_rect, RID p_texture, bool p_tile, const Color & p_modulate, bool p_transpose) ;
	void canvas_item_add_texture_rect_region(RID p_item, const Rect2 & p_rect, RID p_texture, const Rect2 & p_src_rect, const Color & p_modulate, bool p_transpose, bool p_clip_uv) ;
	void canvas_item_add_msdf_texture_rect_region(RID p_item, const Rect2 & p_rect, RID p_texture, const Rect2 & p_src_rect, const Color & p_modulate, int p_outline_size, float p_px_range, float p_scale) ;
	void canvas_item_add_lcd_texture_rect_region(RID p_item, const Rect2 & p_rect, RID p_texture, const Rect2 & p_src_rect, const Color & p_modulate) ;
	void canvas_item_add_nine_patch(RID p_item, const Rect2 & p_rect, const Rect2 & p_source, RID p_texture, const Vector2 & p_topleft, const Vector2 & p_bottomright, RenderingServer::NinePatchAxisMode p_x_axis_mode, RenderingServer::NinePatchAxisMode p_y_axis_mode, bool p_draw_center, const Color & p_modulate) ;
	void canvas_item_add_primitive(RID p_item, const Vector<Point2> & p_points, const Vector<Color> & p_colors, const Vector<Point2> & p_uvs, RID p_texture) ;
	void canvas_item_add_polygon(RID p_item, const Vector<Point2> & p_points, const Vector<Color> & p_colors, const Vector<Point2> & p_uvs, RID p_texture) ;
	void canvas_item_add_triangle_array(RID p_item, const Vector<int> & p_indices, const Vector<Point2> & p_points, const Vector<Color> & p_colors, const Vector<Point2> & p_uvs, const Vector<int> & p_bones, const Vector<float> & p_weights, RID p_texture, int p_count) ;
	void canvas_item_add_mesh(RID p_item, const RID & p_mesh, const Transform2D & p_transform, const Color & p_modulate, RID p_texture) ;
	void canvas_item_add_multimesh(RID p_item, RID p_mesh, RID p_texture) ;
	void canvas_item_add_particles(RID p_item, RID p_particles, RID p_texture) ;
	void canvas_item_add_set_transform(RID p_item, const Transform2D & p_transform) ;
	void canvas_item_add_clip_ignore(RID p_item, bool p_ignore) ;
	void canvas_item_add_animation_slice(RID p_item, double p_animation_length, double p_slice_begin, double p_slice_end, double p_offset) ;
	void canvas_item_set_sort_children_by_y(RID p_item, bool p_enable) ;
	void canvas_item_set_z_index(RID p_item, int p_z) ;
	void canvas_item_set_z_as_relative_to_parent(RID p_item, bool p_enable) ;
	void canvas_item_set_copy_to_backbuffer(RID p_item, bool p_enable, const Rect2 & p_rect) ;
	void canvas_item_attach_skeleton(RID p_item, RID p_skeleton) ;
	void canvas_item_clear(RID p_item) ;
	void canvas_item_set_draw_index(RID p_item, int p_index) ;
	void canvas_item_set_material(RID p_item, RID p_material) ;
	void canvas_item_set_use_parent_material(RID p_item, bool p_enable) ;
	void canvas_item_set_visibility_notifier(RID p_item, bool p_enable, const Rect2 & p_area, const Callable & p_enter_callbable, const Callable & p_exit_callable) ;
	void canvas_item_set_canvas_group_mode(RID p_item, RenderingServer::CanvasGroupMode p_mode, float p_clear_margin, bool p_fit_empty, float p_fit_margin, bool p_blur_mipmaps) ;
	void canvas_item_set_debug_redraw(bool p_enabled) ;
	bool canvas_item_get_debug_redraw() const;
	void canvas_light_create(RID output) ;
	void canvas_light_set_mode(RID p_light, RenderingServer::CanvasLightMode p_mode) ;
	void canvas_light_attach_to_canvas(RID p_light, RID p_canvas) ;
	void canvas_light_set_enabled(RID p_light, bool p_enabled) ;
	void canvas_light_set_transform(RID p_light, const Transform2D & p_transform) ;
	void canvas_light_set_color(RID p_light, const Color & p_color) ;
	void canvas_light_set_height(RID p_light, float p_height) ;
	void canvas_light_set_energy(RID p_light, float p_energy) ;
	void canvas_light_set_z_range(RID p_light, int p_min_z, int p_max_z) ;
	void canvas_light_set_layer_range(RID p_light, int p_min_layer, int p_max_layer) ;
	void canvas_light_set_item_cull_mask(RID p_light, int p_mask) ;
	void canvas_light_set_item_shadow_cull_mask(RID p_light, int p_mask) ;
	void canvas_light_set_directional_distance(RID p_light, float p_distance) ;
	void canvas_light_set_texture_scale(RID p_light, float p_scale) ;
	void canvas_light_set_texture(RID p_light, RID p_texture) ;
	void canvas_light_set_texture_offset(RID p_light, const Vector2 & p_offset) ;
	void canvas_light_set_blend_mode(RID p_light, RenderingServer::CanvasLightBlendMode p_mode) ;
	void canvas_light_set_shadow_enabled(RID p_light, bool p_enabled) ;
	void canvas_light_set_shadow_filter(RID p_light, RenderingServer::CanvasLightShadowFilter p_filter) ;
	void canvas_light_set_shadow_color(RID p_light, const Color & p_color) ;
	void canvas_light_set_shadow_smooth(RID p_light, float p_smooth) ;
	void canvas_light_occluder_create(RID output) ;
	void canvas_light_occluder_attach_to_canvas(RID p_occluder, RID p_canvas) ;
	void canvas_light_occluder_set_enabled(RID p_occluder, bool p_enabled) ;
	void canvas_light_occluder_set_polygon(RID p_occluder, RID p_polygon) ;
	void canvas_light_occluder_set_as_sdf_collision(RID p_occluder, bool p_enable) ;
	void canvas_light_occluder_set_transform(RID p_occluder, const Transform2D & p_xform) ;
	void canvas_light_occluder_set_light_mask(RID p_occluder, int p_mask) ;
	void canvas_occluder_polygon_create(RID output) ;
	void canvas_occluder_polygon_set_shape(RID p_occluder_polygon, const Vector<Vector2> & p_shape, bool p_closed) ;
	void canvas_occluder_polygon_set_cull_mode(RID p_occluder_polygon, RenderingServer::CanvasOccluderPolygonCullMode p_mode) ;
	void canvas_set_shadow_texture_size(int p_size) ;
	void global_shader_parameter_add(const StringName & p_name, RenderingServer::GlobalShaderParameterType p_type, const Variant & p_value) ;
	void global_shader_parameter_remove(const StringName & p_name) ;
	Vector<StringName> global_shader_parameter_get_list() const;
	void global_shader_parameter_set(const StringName & p_name, const Variant & p_value) ;
	void global_shader_parameter_set_override(const StringName & p_name, const Variant & p_value) ;
	Variant global_shader_parameter_get(const StringName & p_name) const;
	RenderingServer::GlobalShaderParameterType global_shader_parameter_get_type(const StringName & p_name) const;
	void global_shader_parameters_load_settings(bool p_load_textures) ;
	void global_shader_parameters_clear() ;
	void free(RID p_rid) ;
	void request_frame_drawn_callback(const Callable & p_callable) ;
	void draw(bool p_swap_buffers, double frame_step) ;
	bool sync() ;
	bool has_changed() const;
	uint64_t get_rendering_info(RenderingServer::RenderingInfo p_info) ;
	String get_video_adapter_name() const;
	String get_video_adapter_vendor() const;
	RenderingDevice::DeviceType get_video_adapter_type() const;
	String get_video_adapter_api_version() const;
	void set_frame_profiling_enabled(bool p_enable) ;
	Vector<RenderingServer::FrameProfileArea> get_frame_profile() ;
	uint64_t get_frame_profile_frame() ;
	double get_frame_setup_time_cpu() const;
	void gi_set_use_half_resolution(bool p_enable) ;
	RID get_test_cube() ;
	void sdfgi_set_debug_probe_select(const Vector3 & p_position, const Vector3 & p_dir) ;
	void set_boot_image(const Ref<Image> & p_image, const Color & p_color, bool p_scale, bool p_use_filter) ;
	Color get_default_clear_color() ;
	void set_default_clear_color(const Color & p_color) ;
	bool has_feature(RenderingServer::Features p_feature) const;
	bool has_os_feature(const String & p_feature) const;
	void set_debug_generate_wireframes(bool p_generate) ;
	void call_set_vsync_mode(DisplayServer::VSyncMode p_mode, DisplayServer::WindowID p_window) ;
	bool is_low_end() const;
	void set_print_gpu_profile(bool p_enable) ;
	Size2i get_maximum_viewport_size() const;
	void call_on_render_thread(const Callable & p_callable) ;

	Error display_server_initialize();
	Error window_create(DisplayServer::WindowID p_window_id, void *p_native_window);
	void window_destroy(DisplayServer::WindowID p_window_id);

	static inline filament::Engine *filamentEngine() {
		return m_filamentEngine;
	}

	static FilamentRenderingServerBackend *get();

	inline const FilamentObjectManager &objects() const {
		return m_objectManager;
	}

	inline void markDirty(FilamentDirtyListEntry *entry) noexcept {
		m_dirtyList.add(entry);
	}

private:

	void upload3DTexture(const std::shared_ptr<FilamentTextureObject> &texture, const Vector<Ref<Image>> & p_data);

	class EnginePointer {
	public:
		EnginePointer(filament::Engine *engine = nullptr, filament::Engine **pointerToPointer = nullptr) noexcept;
		~EnginePointer();

		EnginePointer(EnginePointer &other) = delete;
		EnginePointer &operator =(const EnginePointer &other) = delete;

		inline operator bool() const {
			return static_cast<bool>(m_ptr);
		}

		inline filament::Engine *get() const {
			return m_ptr;
		}

	private:
		filament::Engine *m_ptr;
		filament::Engine **m_pointerToPointer;
	};

	EnginePointer m_engine;
	FilamentObjectManager m_objectManager;
	FilamentDirtyList m_dirtyList;
	std::vector<std::unique_ptr<FilamentWindow>> m_windows;
	static filament::Engine *m_filamentEngine;
};

#endif

